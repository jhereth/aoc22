---
jupyter:
  jupytext:
    formats: 'ipynb,qmd'
    text_representation:
      extension: .qmd
      format_name: quarto
      format_version: '1.0'
      jupytext_version: 1.14.1
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{python}
from collections import defaultdict
from copy import deepcopy
from pprint import pprint


def read_input(s):
    with open(f"./input/{s}") as f:
        data = f.read().splitlines()
        return data
```


## Day 14

```{python}
test_input = """498,4 -> 498,6 -> 496,6
503,4 -> 502,4 -> 502,9 -> 494,9
""".splitlines()

start_point = (500, 0)

test_result = 24

data = test_input

def parse_lines(data):
    result = []
    for line in data:
        # print(f"{line=}")
        poses = line.split(" -> ")
        pos_old = None
        line = []
        for p in poses:
            line.append(pos:=tuple(map(int, p.split(","))))
            if pos_old:
                assert pos[0] == pos_old[0] or pos[1] == pos_old[1]
            pos_old = pos
        result.append(line)
    return result

lines = parse_lines(data)
# pprint(lines)

def build_cave(lines):
    cave = {}
    for line in lines:
        # print(line)
        p1 = line.pop(0)
        while line:
            p2 = line.pop(0)
            # print("p2", p2)
            if p1[0] == p2[0]:
                i, j = 0, 1
            else:
                i, j = 1, 0
            lower, upper = min(p1[j], p2[j]), max(p1[j], p2[j])
            for k in range(lower, upper + 1):
                coords = [0, 0]
                coords[i] = p1[i]
                coords[j] = k
                # print(coords)
                cave[tuple(coords)] = "#"
            p1 = p2
    return cave
# pprint(lines)
cave = build_cave(lines)
# pprint(cave)

def max_y(cave):
    return max(_[1] for _ in cave.keys())

print("Cave depth", max_y(cave))

def next_pos(cave, pos):
    x, y = pos
    if cave.get(p:=(x, y+1)) is None:
        return p
    if cave.get(p:=(x-1, y+1)) is None:
        return p
    if cave.get(p:=(x+1, y+1)) is None:
        return p
    return None

def sand_fall(cave, start_pos=(500,-1)):
    cave = deepcopy(cave)
    depth = max_y(cave)
    i = 0
    path = [start_pos]
    while path:
        pos = path.pop()
        npos = next_pos(cave, pos)
        if npos:
            # print(i, npos, path)
            if npos[1] > depth:
                return i, cave
            path.append(pos)
            path.append(npos)
            continue
        cave[pos] = "o"
        pos = path.pop()
        i += 1
        # print(i, path)
    return i, cave

result = sand_fall(cave)
print("result", result)

def main(data):
    result = None
    lines = parse_lines(data)
    cave = build_cave(lines)
    result = sand_fall(cave)
    return result

assert main(data)[0] == test_result
print(main(data))
print("success")
```
### Sanity Checks
```{python}
data = read_input("14_input.txt")
parse_lines(data)
```

```{python}
data = read_input("14_input.txt")

print("final result", main(data))  # 888
```

## Day 14 - Part 2

```{python}

data = test_input

def dimensions(cave):
    min_x = min(_[0] for _ in cave.keys())
    max_x = max(_[0] for _ in cave.keys())
    depth = max(_[1] for _ in cave.keys())
    return min_x, max_x, depth

def build_floor(cave):
    cave = deepcopy(cave)
    min_x, max_x, depth = dimensions(cave)
    for i in range(min_x - 200, max_x + 201):
        cave[(i, depth + 2)] = "#"
    return cave


lines = parse_lines(data)
# pprint(lines)
cave = build_cave(lines)
# pprint(cave)
floored_cave = build_floor(cave)
# pprint(floored_cave)

i, filled_cave = sand_fall(floored_cave)

def print_cave(cave):
    minx, maxx, depth = dimensions(cave)
    print(minx, maxx, depth)
    rows = []
    for y in range(depth + 1):
        s = "|"
        for x in range(minx, maxx+1):
            s += cave.get((x,y), ".")
        rows.append(s + "|")
    return "\n".join(rows)

def main2(data):
    lines = parse_lines(data)
    cave = build_cave(lines)
    floored = build_floor(cave)
    result, filled = sand_fall(floored)
    return result, filled

result, filled = main2(data)
print("Result", result)
print(print_cave(filled))


# print("test result", main2(data))

```
```{python}
data = read_input("14_input.txt")

result, filled = main2(data)
print("Result", result)
print(print_cave(filled))
```


## Day 15

just thinking...

```
Sensort at 8,7
Beacon at 2, 10
dist = abs(8-2) + abs(7-10) = 9

y = 12

min x: 
    abs(12-7) = 5
    dist = 9 - 5 = 4
    8-4 = 4
max x:     8 + 4 = 12

dist((8,7),(4,12)) = 4 + 5 = 9
dist((8,7),(12,12)) = 4 + 5 = 9
```

```{python}
test_input = """Sensor at x=2, y=18: closest beacon is at x=-2, y=15
Sensor at x=9, y=16: closest beacon is at x=10, y=16
Sensor at x=13, y=2: closest beacon is at x=15, y=3
Sensor at x=12, y=14: closest beacon is at x=10, y=16
Sensor at x=10, y=20: closest beacon is at x=10, y=16
Sensor at x=14, y=17: closest beacon is at x=10, y=16
Sensor at x=8, y=7: closest beacon is at x=2, y=10
Sensor at x=2, y=0: closest beacon is at x=2, y=10
Sensor at x=0, y=11: closest beacon is at x=2, y=10
Sensor at x=20, y=14: closest beacon is at x=25, y=17
Sensor at x=17, y=20: closest beacon is at x=21, y=22
Sensor at x=16, y=7: closest beacon is at x=15, y=3
Sensor at x=14, y=3: closest beacon is at x=15, y=3
Sensor at x=20, y=1: closest beacon is at x=15, y=3""".splitlines()

data = test_input
from attr import define
@define
class Sensor:
    x: int
    y: int
    beac_x: int
    beac_y: int
    distance: int

import re
def parse_input(data):
    sensors = []
    for line in data:
        # print(line)
        m = re.match(r"^Sensor at x=(?P<sens_x>-?[0-9]+), y=(?P<sens_y>-?[0-9]+): closest beacon is at x=(?P<beac_x>-?[0-9]+), y=(?P<beac_y>-?[0-9]+)", line)
        sens_x, sens_y, beac_x, beac_y = int(m["sens_x"]), int(m["sens_y"]), int(m["beac_x"]), int(m["beac_y"])
        dist = abs(sens_x - beac_x) + abs(sens_y-beac_y)
        # print(sens_x, sens_y, beac_x, beac_y, dist)
        sensors.append(Sensor(sens_x, sens_y, beac_x, beac_y, dist))
        # print(m.groups())
    return sensors

import operator as op
def notthere(sensors, row, cand_max=20):
    segments = []
    knowns = set()
    for s in sensors:
        if s.y == row:
            knowns.add(s.x)
        if s.beac_y == row:
            knowns.add(s.beac_x)
        # print(s.distance, s.y, row)
        dist = s.distance - abs(s.y - row)
        if dist < 0:
            continue
        minx, miny = s.x - dist, s.x + dist
        # print(s, dist, minx, miny)
        segments.append((minx, miny))
    segments.sort(key=op.itemgetter(0))
    count = 0
    pos = min(_[0] for _ in segments)
    candidates = [_ for _ in range(0, pos)]
    # print(row, "1", candidates)
    for segment in segments:
        x1, x2 = segment
        # print("----", x1, x2)
        if pos <= x1:
            candidates += [_ for _ in range(pos, x1)]
            # print(row, "2", candidates)
            # print("case 1")
            count += x2 - x1 + 1
            pos = x2 + 1
            # continue
        if x1 < pos:
            if x2 < pos:
                # print("case 2")
                continue
            # print("case 3")
            count += x2 - pos + 1
            pos = x2 + 1
        # print(pos, count)
    candidates += [_ for _ in range (pos, cand_max)]
    # print(row, "3", candidates)
    return count - len(knowns), candidates

sensors = parse_input(data)
x = notthere(sensors, 10)
# print(x)

def main(data, row):
    sensors = parse_input(data)
    result, _ = notthere(sensors, row)
    return result


assert main(data, 10) == 26
# print(main(data))
print("success")
```

```{python}
data = read_input("15_input.txt")

print("final result", main(data, 2000000))
```

## Day 15 - Part 2

```{python}

data = test_input
sensors = parse_input(data)

cand_list = [notthere(sensors, row)[1] for row in range(21)]

for i, row in enumerate(cand_list):
    if row:
        print(i, row)

def main2(data):
    result = None
    return result

# print("test result", main2(data))

```
```{python}
data = read_input("15_input.txt")
sensors = parse_input(data)

# print(sensors)
from tqdm import tqdm
cand_list = []

maxcand = 4_000_000
for row in tqdm(range(4_000_000)):
    # print(_)
    cand_list.append(notthere(sensors, row, cand_max=maxcand)[1])

for i, row in enumerate(cand_list):
    if row:
        print(i, row)
        pass

# 2639657 [3435885]
print("final result 2", main2(data))
```


```{python}
print("Tuning Frequency", 2639657 + 4_000_000 * 3435885)

```
## Day 16

```{python}
test_input = """
""".splitlines()

data = test_input

def main(data):
    result = None
    return result

print(main(data))
print("success")
```

```{python}
data = read_input("16_input.txt")

print("final result", main(data))
```

## Day 16 - Part 2

```{python}

data = test_input

def main2(data):
    result = None
    return result

print("test result", main2(data))

```
```{python}
data = read_input("16_input.txt")

print("final result 2", main2(data))
```

## Day 17

```{python}
test_input = """
""".splitlines()

data = test_input

def main(data):
    result = None
    return result

print(main(data))
print("success")
```

```{python}
data = read_input("17_input.txt")

print("final result", main(data))
```

## Day 17 - Part 2

```{python}

data = test_input

def main2(data):
    result = None
    return result

print("test result", main2(data))

```
```{python}
data = read_input("17_input.txt")

print("final result 2", main2(data))
```
